# bit和数据类型
## bit——信息的基本单位
这大概是一个数字化的过程，把点评抽象成0和1，从而用二进制表述数值  
## 数据类型
数值的表达方式多种多样：  
- 单进制：比如用手指表示，十进制5相当于是"11111"  
- 十进制"5"  
- 罗马人用字母"V"代表数值5  
- ***二进制***  

只能表达数值是不够的，计算机还需要有操作这些数值的能力。  
> 如果我们不仅定义了数值的表达方式（或编码方式），同时还定义了相关的操作方法，则在定义上称该表达方式为一种数据类型。  

每个计算机指令集（ISA: Instruction Set Architecture，感觉应该翻译成指令集架构）都定义了一组数据类型及其对应的操作指令  

本书我们用补码表示正负整数，用ASCII码表示字符，用浮点表示浮点数(hhh说了和说了一样)  

# 整数数据类型
## 无符号整数
有$k$个bit可以表示$2^{k}$个无符号整数（$2^{k}-1$）。e.g. 5-bit的无符号整数可以表示0~31  
## 有符号整数
有$k$个bit可以表示$-2^{k-1}\sim2^{k-1}-1$的数  
为了表示正负数，有很多种办法，书里讲了三种：  
- 符号位表示法：第一位标记符号，剩下表示绝对值  
- 反码：复数就把绝对值的二进制按位取反  
- 补码（下面会讲）  

# 补码
现在大部分计算机都用这个
使用补码的原因：设计负数的表示方式的时候要使实现功能的逻辑电路尽可能简单。几乎所有的计算机都采用了相同的实现机制完成了加法运算，即**算术逻辑运算单元** (Arithmetic and Logic Unit, ALU)。已知他接受两个二进制输入并按位相加。我们需要找到一种编码使正负数都能通过ALU实现加法。**补码**是一种合适的方案。  

补码的本质我觉得可以这么理解：假设一个钟只有秒针，以角度为单位，$-20^{\circ}$和$340^{\circ}$是一个东西，所有减法等能转换成加法  

结论：***正数的补码与原码一致，复数的补码是反码+1***  

# bit运算之一：算数运算
## 加减法
加法正常加，减法等于加上一个数的相反数  
## 符号拓展
背景：一般小的数会用较少的bit来存放来减少空间占用，但是当他和大数相加的时候，如果不补位，就会出错  
不难发现：**在正数前面补0和在复数前面补1并不会改变他们的值**  
所以运算时要补位，这个操作叫**符号拓展 (Sign-Extension, SEXT)**  